server=======================================
redis_version: Redis 服务器版本
redis_git_sha1: Git SHA1
redis_git_dirty: Git dirty flag
redis_build_id: redis build id
redis_mode: 运行模式，单机或者集群
os: redis服务器的宿主操作系统
arch_bits: 架构(32或64位)
multiplexing_api: Redis 所使用的事件处理机制
atomicvar_api: redis使用的GNU Compiler Collection
gcc_version: 编译redis时所使用的gcc版本
process_id: redis服务器进程的pid
run_id: redis服务器的随机标识符(用于sentinel和集群)
tcp_port: redis服务器监听端口
uptime_in_seconds: 自 Redis 服务器启动以来，经过的秒数
uptime_in_days: 自 Redis 服务器启动以来，经过的天数
hz: redis内部调度（进行关闭timeout的客户端，删除过期key等等）频率,程序规定serverCron每秒运行10次。
lru_clock: 自增的时钟，用于LRU管理,该时钟100ms(hz=10,因此每1000ms/10=100ms执行一次定时任务)更新一次。
executable: 服务器可执行文件的路径
config_file: 配置文件路径

clients=======================================
connected_clients: 已连接客户端的数量(不包括通过slave连接的客户端)
client_longest_output_list:  当前连接的客户端当中，最长的输出列表
client_biggest_input_buf: 当前连接的客户端当中，最大输入缓存，用client list命令观察qbuf和qbuf-free两个字段最大值
blocked_clients: 正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量

memory=======================================
used_memory: 由 Redis 分配器分配的内存总量，以字节（byte）为单位
used_memory_human: 以人类可读的格式返回redis分配的内存总量
used_memory_rss: 从操作系统的角度，返回 Redis 已分配的内存总量（俗称常驻集大小）。这个值和 top 、 ps 等命令的输出一致。
used_memory_rss_human: 可读的先前值表示
used_memory_peak: Redis 的内存消耗峰值（以字节为单位）
used_memory_peak_human: 以人类可读的格式返回redis的内存消耗峰值
used_memory_peak_perc: 已用内存峰值占已用内存的百分比
used_memory_overhead: 服务器分配用于管理其内部数据结构的所有开销的总字节数
used_memory_startup: Redis启动时消耗的初始内存量（以字节为单位）
used_memory_dataset: 数据集的字节大小（已用内存开销减去已用内存）
used_memory_dataset_perc: 已用内存数据集超出净内存使用量的百分比（已用内存减去已用内存启动）
total_system_memory: Redis主机拥有的内存总量
total_system_memory_human: 可读的先前值表示
used_memory_lua: lua引擎所使用的内存大小(以字节为单位)
used_memory_lua_human: 可读的先前值表示
maxmemory: maxmemory配置指令的值
maxmemory_human: 可读的先前值表示
maxmemory_policy: maxmemory-policy配置指令的值
mem_fragmentation_ratio: used_memory_rss 和 used_memory 之间的比率
mem_allocator: 在编译时指定的redis所使用的内存分配器。可以是libc、jemalloc或者tcmalloc
active_defrag_running: 指示活动碎片整理是否处于活动状态的标志
lazyfree_pending_objects: 等待释放的对象数（通过使用ASYNC选项调用UNLINK或FLUSHDB和FLUSHALL的结果）

persistence=======================================
loading: 指示转储文件的加载是否正在进行的标志
rdb_changes_since_last_save: 离最近一次成功生成rdb文件，写入命令的个数，即有多少个写入命令没有 持久化
rdb_bgsave_in_progress: 服务器是否正在创建rdb文件
rdb_last_save_time: 离最近一次成功创建rdb文件的时间戳。当前时间戳 - rdb_last_save_time=多少秒未成功生成rdb文件
rdb_last_bgsave_status: 最近一次rdb持久化是否成功
rdb_last_bgsave_time_sec: 最近一次成功生成rdb文件耗时秒数
rdb_current_bgsave_time_sec: 如果服务器正在创建rdb文件，那么这个域记录的就是当前的创建操作已经耗费的秒数
rdb_last_cow_size: 最后一次RBD保存操作期间写时复制分配的大小（以字节为单位）
aof_enabled: 是否开启了aof
aof_rewrite_in_progress: 标识aof的rewrite操作是否在进行中
aof_rewrite_scheduled: 一旦正在进行的rdb保存完成，将调度指示aof重写操作的标志。
aof_last_rewrite_time_sec: 最近一次aof rewrite耗费的时长
aof_current_rewrite_time_sec: 如果rewrite操作正在进行，则记录所使用的时间，单位秒
aof_last_bgrewrite_status: 上次bgrewriteaof操作的状态
aof_last_write_status: 上次aof写入状态
aof_last_cow_size: AOF过程中父进程与子进程相比执行了多少修改(包括读缓冲区，写缓冲区，数据修改等)。
aof_current_size: aof当前尺寸
aof_base_size: 服务器启动时或者aof重写最近一次执行之后aof文件的大小
aof_pending_rewrite: 是否有aof重写操作在等待rdb文件创建完毕之后执行
aof_buffer_length: aof buffer的大小
aof_rewrite_buffer_length: aof rewrite buffer的大小
aof_pending_bio_fsync: 后台I/O队列里面，等待执行的fsync调用数量
aof_delayed_fsync: 被延迟的fsync调用数量
loading_start_time: 加载操作开始的基于纪元的时间戳
loading_total_bytes: 文件总大小
loading_loaded_bytes: 已加载的字节数
loading_loaded_perc: 相同的值以百分比表示
loading_eta_seconds: 预计完成所需的时间（以秒为单位）
stats=======================================
total_connections_received: 新创建连接个数,如果新创建连接过多，过度地创建和销毁连接对性能有影响，说明短连接严重或连接池使用有问题，需调研代码的连接设置
total_commands_processed: redis处理的命令数
instantaneous_ops_per_sec: redis当前的qps，redis内部较实时的每秒执行的命令数
total_net_input_bytes: redis网络入口流量字节数
total_net_output_bytes: redis网络出口流量字节数
instantaneous_input_kbps: redis网络入口kps
instantaneous_output_kbps: redis网络出口kps
rejected_connections: 拒绝的连接个数，redis连接个数达到maxclients限制，拒绝新连接的个数
sync_full: 主从完全同步成功次数
sync_partial_ok: 主从部分同步成功次数
sync_partial_err: 主从部分同步失败次数
expired_keys: 运行以来过期的key的数量
evicted_keys: 运行以来剔除(超过了maxmemory后)的key的数量
keyspace_hits: 命中次数
keyspace_misses: 没命中次数
pubsub_channels: 当前使用中的频道数量
pubsub_patterns: 当前使用的模式的数量
latest_fork_usec: 最近一次fork操作阻塞redis进程的耗时数，单位微秒
migrate_cached_sockets: 为迁移目的而打开的插槽数
slave_expires_tracked_keys: 从实例到期key数量
active_defrag_hits: 主动碎片整理命中次数
active_defrag_misses: 主动碎片整理未命中次数
active_defrag_key_hits: 主动碎片整理key命中次数
active_defrag_key_misses: 主动碎片整理key未命中次数
replication=======================================
role: 实例的角色，是master or slave
master_replid: Redis服务器的复制ID。
master_replid2: 故障转移后用于PSYNC的辅助复制ID。
master_repl_offset: 主从同步偏移量,此值如果和上面的offset相同说明主从一致没延迟
second_repl_offset: 接受复制ID的偏移量
repl_backlog_active: 复制积压缓冲区是否开启
repl_backlog_size: 复制积压缓冲大小
repl_backlog_first_byte_offset: 复制缓冲区里偏移量的大小
master_host: 此节点对应的master的ip
master_port: 此节点对应的master的port
master_link_status: slave端可查看它与master之间同步状态,当复制断开后表示down
master_last_io_seconds_ago:主库多少秒未发送数据到从库
master_sync_in_progress: 从服务器是否在与主服务器进行同步
slave_repl_offset: slave复制偏移量
slave_priority: slave优先级
slave_read_only: 从库是否设置只读
master_link_down_since_seconds: 链接断开后经过的秒数
connected_slaves: 连接的slave实例个数
min_slaves_good_slaves: 当前认为良好的副本数
slaveXXX: id, IP address, port, state, offset, lag
cpu=======================================
used_cpu_sys: 将所有redis主进程在核心态所占用的CPU时求和累计起来
used_cpu_user:将所有redis主进程在用户态所占用的CPU时求和累计起来
used_cpu_sys_children: 将后台进程在核心态所占用的CPU时求和累计起来
used_cpu_user_children: 将后台进程在用户态所占用的CPU时求和累计起来
commandstats=======================================
cluster=======================================
cluster_enabled: 实例是否启用集群模式,0为未启用
keyspace=======================================

















